## Exql v2 Release Note

2022-02-03
Yusuke SAKURAI
Software Engineer at LoiLo Inc.

## Table of contents

- [Exql v2 Release Note](#exql-v2-release-note)
- [Table of contents](#table-of-contents)
- [New methods of Saver](#new-methods-of-saver)
  - [Delete/DeleteContext](#deletedeletecontext)
  - [Query Executors](#query-executors)
  - [Query maker for bulk insertion](#query-maker-for-bulk-insertion)
- [Finder interface](#finder-interface)
- [StmtExecutor](#stmtexecutor)
- [Interface Updates](#interface-updates)
  - [New interfaces](#new-interfaces)
  - [Removed interfaces](#removed-interfaces)
- [Changes in generated codes](#changes-in-generated-codes)
- [exql/query package](#exqlquery-package)
  - [query.Condition](#querycondition)
  - [query.Builder](#querybuilder)

## New methods of Saver

New methods were introduced into `exql.Saver`.

### Delete/DeleteContext

```go
Delete(table string, where q.Condition) (sql.Result, error)
DeleteContext(ctx context.Context, table string, where q.Condition) (sql.Result, error)
```

Those are methods for deleting entities from database. Its usage are mostly the same as Update/UpdateContext. It requires where condition clause, not accepting empty condition that causes entire deletion of data from database. Please use them carefully.

### Query Executors

```go
Exec(query q.Query) (sql.Result, error)
ExecContext(ctx context.Context, query q.Query) (sql.Result, error)
Query(query q.Query) (*sql.Rows, error)
QueryContext(ctx context.Context, query q.Query) (*sql.Rows, error)
QueryRow(query q.Query) (*sql.Row, error)
QueryRowContext(ctx context.Context, query q.Query) (*sql.Row, error)
```

Those are methods that execute new `query.Query` interface directly instead of raw SQL statements. It is documented in detail later.

### Query maker for bulk insertion

```go
func QueryForBulkInsert[T Model](modelPtrs ...T) (q.Query, error)
```

It is similar function to `QueryForInsert`/`QueryForUpdate`, making insert statement for multiple entities. It is useful for inserting models in batch. Unlike a single insertion, auto-increment field are not fulfilled automatically.

Example:

```go
q, err := exql.QueryForBulkInsert(user1, user2)
result, err := db.Exec(q)
// INSERT INTO users (age,name) VALUES (?,?),(?,?)
// [20, go, 30, lang]"
```

## Finder interface

A new interface, `Finder` was intoroduced. This is integrated interface of quering records and maping rows into models. In former verison, a typical SELECT query and code were like this:

```go
rows, err := db.DB().Query(`SELECT * FROM users WHERE id = ?`, 1)
if err != nil {
  log.Fatal(err)
} else {
  var user model.Users
  if err := db.Map(rows, &user); err != nil {
    log.Fatal(err)
  }
  log.Printf("%d", user.Id) // -> 1
}
```

That can be rewritten in new version briefly:

```go
var user model.Users
err := db.Find(query.Q(`SELECT * FROM users WHERE id = ?`, 1), &user)
if err != nil {
  log.Fatal(err)
}
log.Printf("%d", user.Id) // -> 1
```

`Mapper` has been deprecated and is going te be removed in the next major version. Faster refactoring is recommended.

## StmtExecutor

`StmtExecutor` is the `Executor` that caches queries as `sql.Stmt`. This is designed for the repeated executon of same query. It prevents the potential lack of connection pool caused by too many prepared satatemts

```go
stmtExecer := exql.NewStmtExecutor(tx.Tx())
defer stmtExecer.Close()
stmtSaver := exql.NewSaver(stmtExecer)
stmtSaver.Insert(&model.Users{Name: "user1"})
stmtSaver.Insert(&model.Users{Name: "user2"})
```

The code above is equivalent to SQL below:

```sql
PREPARE stmt FROM "INSERT INTO `users` (`name`) VALUES (?)";
SET @name = "user1";
EXECUTE stmt USING @name;
SET @name = "user2";
EXECUTE stmt USING @name;
DEALLOCATE PREPARE stmt;
```

This has the advantage on the concurrent execution of same queries because it holds a single underlying connection for the statement. Without preparation, even if they are identical, different connection is assigned to each query.

## Interface Updates

### New interfaces

```go
// An abstraction of sql.DB/sql.Tx
type Executor interface {
  Exec(query string, args ...any) (sql.Result, error)
  ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)
  Query(query string, args ...any) (*sql.Rows, error)
  QueryContext(ctx context.Context, query string, args ...any) (*sql.Rows, error)
  QueryRow(query string, args ...any) *sql.Row
  QueryRowContext(ctx context.Context, query string, args ...any) *sql.Row
}

type Model interface {
  TableName() string
}

type ModelUpdate interface {
  UpdateTableName() string
}
```

Some interfaces introduced for the convenience.

### Removed interfaces

Two interfaces were removed.

- `exql.Clause`: Use `query.Query` or `query.Condition` instead.
- `exql.SET`: Use `map[string]any` instead.

## Changes in generated codes

Codes that generated by `Generator` changed partially. It was simplified for presenting model's table name.

Old:

```go
type usersTable struct {}
var UsersTable = &usersTable{}
func (u *usersTable) Name() string {
  return "users"
}
```

New:

```go
const UsersTableName = "users"
```

## exql/query package

`query` package is the biggest new feature in exql v2. It is an independent framework for building SQL query. In exql v1, except for insert/update queries, you must write a raw SQL down.
However, from the real development for 3 years, we've found there are many cases for constructing SQL queries dynamically with `fmt.Sprintf`. The typical code is below:

```go
// make a select statement with the dynamic condition clause
ids := []int{1,2,3}
placeholders := "?,?,?" // depends on ids size
q := fmt.Sprintf(`SELECT * FROM users WHERE id IN (%s) AND age = ?`, placeholders)
var args []any
args = append(args, util.MapToInterfaces(ids)..., )
args = append(args, 20)
rows, err := db.DB().Query(q, args...)
```

This is much simple, straight expression of code that Gophers like. But there are much redundant, unsafe codes and you also must do it repeat yourself. We designed the system for making the query construction more simple, short and safe.
We paid much attention to not losing clearness of SQL generation. The implicit generation of an ambiguous SQL statements, especially by library, is terribly harmful. Whole statements of SQL query should be written down by programmers as possible, it should help them partially. That is a good ORM we think.

The code above can be rewritten in v2:

```go
 q := query.New(
  `SELECT * FROM users WHERE id IN (:?) AND age = ?`, query.V(1,2,3), 20,
)
// SELECT * FROM users WHERE id IN (?,?,?) AND age = ?
// [1,2,3,20]
rows, err := db.Query(q)
```

You noticed an unfamiliar symbol `:?`, that is the new designated placeholder of exql. It is accepted by `query.New` and many methods in the package and interpolated by the corresponding value in rest arguments. In this case, the first argument, `query.V()` is used. `query.V()` is one of utility function that makes `query.Query` interface. `query.Query` interface is an abstraction of the query component and argument values. It holds query string and value separately. It embeds string into the final SQL statement and passing values later in order. The built query object can be passed to `exql.Saver`, getting execution results from the database.

What is the functionality of `query.V()`?

The code below:

```go
ids := []int{1,2}
db.Query(query.New("select * from users where id in (:?)", query.V(ids...)))
```

...is the same as:

```go
db.DB().Query("select * from users where id in (?,?)", 1, 2)
```

`query.V()` transforms values to SQL placeholder (`?`) and joins them by commas. Actual values are stored in the buffer and passed on calling `Exec`/`Query` methods of `sql.DB`.
By using those functions, dynamic SQL generation gets more simple and code less.

### query.Condition

`query.Condition` is the builder especially for the condition of where clause.

```go
cond := query.Cond("id = ?", 1)
cond.And("age >= ?", 20)
cond.And("name in (:?)", query.V("go","lang"))
q := query.New("select * from users where :?", cond)
// select * from users where id = ? and age >= ? and name in (?,?)
// [1, 20, go, lang]
```

### query.Builder

`query.Builder` is the general utility for building query dynamically. It has very similar interfaces to `strings.Builder`. But it is different in points that it accepts exql placeholder and holds values separately.

```go
var qb query.Builder
qb.Sprintf("SELECT * FROM %s", "users")
qb.Query("WHERE id IN (:?) AND age >= ?", query.V(1,2), 20)
// SELECT * FROM users WHERE id IN (?,?) AND age >= ?
// [1,2,20]
rows, err := db.Query(qb.Build())
```
